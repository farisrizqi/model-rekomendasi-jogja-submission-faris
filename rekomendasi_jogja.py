# -*- coding: utf-8 -*-
"""Rekomendasi-Jogja.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v3QlAuJ3jqk-umCyjrES225aMqbXyYjA

# Proyek Sistem Rekomendasi

- Author: Faris Nur Rizqiawan
- Platform: Dicoding Submission – Proyek Akhir Machine Learning Terapan
- Domain: Lingkungan
- Metode: Collaborative Filtering (Deep Learning) dan Content-Based Filtering (TF-IDF)

# Instalasi dan Import Library
"""

!pip install Sastrawi

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import math

from sklearn.feature_extraction.text import TfidfVectorizer
from Sastrawi.StopWordRemover.StopWordRemoverFactory import StopWordRemoverFactory
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import LabelEncoder

# Import TensorFlow/Keras secara tunggal
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Embedding, Flatten, Concatenate, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

"""# Load Dataset"""

from google.colab import drive
drive.mount('/content/drive')

tourism_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/backup-submission/model-rekomendasi/tourism_jogja.csv")
rating_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/backup-submission/model-rekomendasi/tourism_rating.csv")
user_df = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/backup-submission/model-rekomendasi/user.csv")

"""**insight:**
- tourism_df -> tourism_jogja.csv: Informasi objek wisata
- rating df -> tourism_rating.csv: Rating pengguna terhadap objek wisata
- user_df -> user.csv: Data pengguna

# Exploratory Data Analysis (EDA)

### Cek Informasi Dataset dan Menampilkan Data Teratas
"""

# Data Wisata
tourism_df.info(),
tourism_df.head()

# Data Rating
rating_df.info(),
rating_df.head()

# Data User
user_df.info(),
user_df.head()

"""### Cek Missing Value


"""

# Data Wisata
tourism_df.isnull().sum()

# Data Rating
rating_df.isnull().sum()

# Data User
user_df.isnull().sum()

"""### Visualisasi Data

#### Distribusi Tempat Wisata Jogja
"""

# Distribution of 'type'
type_counts = tourism_df['type'].value_counts()

# Plotting
plt.figure(figsize=(16, 10))

# 1. Distribution of vote_average
plt.subplot(2, 2, 1)
sns.histplot(tourism_df['rating'], bins=20, kde=True, color='skyblue')
plt.title('Distribusi Rating (vote_average)')

# 2. Distribution of htm
plt.subplot(2, 2, 2)
sns.histplot(tourism_df['htm'], bins=30, kde=True, color='salmon')
plt.title('Distribusi Harga Tiket Masuk (HTM)')

# 3. Count of each tourism_df type
plt.subplot(2, 2, 3)
sns.countplot(data=tourism_df, y='type', order=type_counts.index, palette='viridis')
plt.title('Jumlah Tempat Wisata per Kategori')

# 4. Map of tourism_df locations (scatter by lat/lon)
tourism_df['latitude'] = pd.to_numeric(tourism_df['latitude'], errors='coerce')
tourism_df['longitude'] = pd.to_numeric(tourism_df['longitude'], errors='coerce')

plt.subplot(2, 2, 4)
sns.scatterplot(x='longitude', y='latitude', hue='type', data=tourism_df, palette='tab10', legend=False)
plt.title('Sebaran Lokasi Tempat Wisata')

plt.tight_layout()
plt.show()

"""**Insight**:

Hasil visualisasi memberikan pemahaman tentang distribusi rating, harga, jenis wisata, dan sebaran geografis tempat wisata. Ini penting untuk menyusun sistem rekomendasi yang mempertimbangkan preferensi dan keterjangkauan pengguna.

#### Distribusi Rating Wisata
"""

# Copy rating data
rating = rating_df.copy()

# Grouping
ratings_per_place = rating.groupby('Place_Id')['Place_Ratings'].count().sort_values(ascending=False)
ratings_per_user = rating.groupby('User_Id')['Place_Ratings'].count().sort_values(ascending=False)
rating_distribution = rating['Place_Ratings'].value_counts().sort_index()

# Basic stats
rating_stats = rating['Place_Ratings'].describe()

# Plotting
plt.figure(figsize=(16, 10))

# 1. Distribution of ratings
plt.subplot(2, 2, 1)
sns.countplot(x='Place_Ratings', data=rating, palette='Set2')
plt.title('Distribusi Nilai Rating')

# 2. Number of ratings per place
plt.subplot(2, 2, 2)
sns.histplot(ratings_per_place, bins=30, kde=False, color='orange')
plt.title('Jumlah Rating per Tempat Wisata')
plt.xlabel('Jumlah Rating')
plt.ylabel('Jumlah Tempat')

# 3. Number of ratings per user
plt.subplot(2, 2, 3)
sns.histplot(ratings_per_user, bins=30, kde=False, color='green')
plt.title('Jumlah Rating per User')
plt.xlabel('Jumlah Rating')
plt.ylabel('Jumlah User')

# 4. Top 10 most rated places
top_rated_places = ratings_per_place.head(10)
plt.subplot(2, 2, 4)
sns.barplot(x=top_rated_places.values, y=top_rated_places.index, palette='mako')
plt.title('10 Tempat Wisata Paling Banyak Dirating')
plt.xlabel('Jumlah Rating')

plt.tight_layout()
plt.show()

"""**Insight:**

Distribusi rating pengguna cukup merata dengan kecenderungan nilai sedang hingga tinggi. Tempat dengan jumlah rating tertinggi dapat menjadi acuan rekomendasi populer atau baseline rekomendasi bagi pengguna baru.

#### Distribusi User / Pengguna Wisata
"""

# Visualisasi distribusi umur dan jenis kelamin
plt.figure(figsize=(12, 5))

# 1. Distribusi umur
plt.subplot(1, 2, 1)
sns.histplot(user_df['Age'], bins=20, kde=True, color='steelblue')
plt.title('Distribusi Umur User_df')
plt.xlabel('Umur')

# 2. Distribusi lokasi (Modified part)
plt.subplot(1, 2, 2)
# Get the count of each location and plot it
location_counts = user_df['Location'].value_counts()
sns.barplot(x=location_counts.values, y=location_counts.index, palette='pastel')
plt.title('Distribusi Lokasi User')
plt.xlabel('Jumlah User')
plt.ylabel('Lokasi')


plt.tight_layout()
plt.show()

"""**Insight:**

Grafik diatas memaparkan demografi pengguna wisata yang meliputi usia dan keberadaan asal pengguna. Informasi ini berguna untuk menyesuaikan sistem rekomendasi agar lebih relevan terhadap kelompok demografi utama yang menggunakan aplikasi.

#### Korelasi Rating User
"""

# Merge rating_df with tourism_df on Place_Id
merged_rating_tourism = pd.merge(rating_df, tourism_df, left_on='Place_Id', right_on='place_id', how='inner')

# Merge the result with user_df on User_Id
merged_data = pd.merge(merged_rating_tourism, user_df, left_on='User_Id', right_on='User_Id', how='inner')

# Visualisasi Korelasi
plt.figure(figsize=(15, 5))

# Correlation between Place_Ratings and tourism_df rating
plt.subplot(1, 3, 1)
sns.scatterplot(x='rating', y='Place_Ratings', data=merged_data)
plt.title('Korelasi antara Rating Tempat Wisata dan Rating User')
plt.xlabel('Rating Tempat Wisata (tourism_df)')
plt.ylabel('Rating User (rating_df)')

# Correlation between Place_Ratings and htm
plt.subplot(1, 3, 2)
sns.scatterplot(x='htm', y='Place_Ratings', data=merged_data)
plt.title('Korelasi antara HTM dan Rating User')
plt.xlabel('HTM')
plt.ylabel('Rating User')

# Correlation between Place_Ratings and Age
plt.subplot(1, 3, 3)
sns.scatterplot(x='Age', y='Place_Ratings', data=merged_data)
plt.title('Korelasi antara Umur User dan Rating User')
plt.xlabel('Umur')
plt.ylabel('Rating User')

plt.tight_layout()
plt.show()

"""**Insight:** <br>
Berdasarkan grafik korelasi:
- Tidak ada korelasi kuat antara rating tempat wisata dengan rating user.
- Harga tiket masuk (HTM) tidak terlalu mempengaruhi rating user.
- Usia pengguna juga tidak menunjukkan tren yang konsisten dalam pemberian rating.

# Modeling Content-Based Filtering

### Pre Processing TF-IDF Vectorization
"""

tourism_df_pre = tourism_df.copy()

# Inisialisasi stopword Sastrawi
try:
    factory = StopWordRemoverFactory()
    sastrawi_stopwords = factory.get_stop_words()
except NameError:
    print("Error: Sastrawi belum terinstal atau belum diimpor.")
    sastrawi_stopwords = []

# TF-IDF Vectorizer dengan stopword Sastrawi
tfidf = TfidfVectorizer(stop_words=sastrawi_stopwords, max_features=500)
tfidf_matrix = tfidf.fit_transform(tourism_df_pre['description'].fillna(''))

print('Shape TF-IDF Matrix:', tfidf_matrix.shape)

"""**Insight:**

- Deskripsi tempat wisata dikonversi ke bentuk numerik menggunakan TF-IDF dengan 500 fitur, setelah menghapus stopwords Bahasa Indonesia.
- Hasilnya berupa matriks TF-IDF yang siap digunakan untuk menghitung kemiripan antar tempat wisata.

### Modelling dan Rekomendasi
"""

# Hitung Cosine Similarity dari matriks TF-IDF
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)
cosine_sim

"""**Insight:**
- Matriks cosine similarity dihitung dari TF-IDF untuk mengukur tingkat kemiripan antar deskripsi tempat wisata.
"""

cosine_sim_df_desc = pd.DataFrame(
    cosine_sim, index=tourism_df_pre['name'], columns=tourism_df_pre['name'])

print('Shape description-based similarity dataframe:', cosine_sim_df_desc.shape)

"""**Insight:**
- Dibuat DataFrame kemiripan antar tempat wisata berdasarkan nama, sehingga memudahkan pencarian tempat yang mirip satu sama lain.
"""

def recommend_places_content_based_desc(place_name, desc_sim_df, top_n=5, original_tourism_df=tourism_df):
    """
    Rekomendasi tempat wisata berdasarkan kemiripan deskripsi (TF-IDF Cosine Similarity).
    """
    if place_name not in desc_sim_df.index:
        print(f"Tempat '{place_name}' tidak ditemukan dalam data similarity.")
        return pd.DataFrame()

    # Ambil skor kemiripan untuk tempat yang diberikan
    sim_scores = desc_sim_df.loc[place_name].squeeze()

    # Fallback jika hasil bukan Series
    if not isinstance(sim_scores, pd.Series):
        sim_scores = pd.Series(sim_scores, index=desc_sim_df.columns)

    # Hilangkan kemiripan dengan dirinya sendiri
    sim_scores = sim_scores.drop(place_name, errors='ignore')

    # Ambil top N+5 untuk menghindari duplikat
    top_similar = sim_scores.sort_values(ascending=False).head(top_n + 5)

    # Filter dan ambil data tempat yang sesuai
    recommended_names = top_similar.index.tolist()
    recommendations = original_tourism_df[original_tourism_df['name'].isin(recommended_names)].copy()

    # Tambahkan skor kemiripan
    recommendations['similarity_score'] = recommendations['name'].map(top_similar.to_dict())

    # Urutkan dan ambil top N unik berdasarkan nama
    recommendations = (
        recommendations.sort_values(by='similarity_score', ascending=False)
        .drop_duplicates(subset='name')
        .head(top_n)
        .reset_index(drop=True)
    )

    return recommendations[['name', 'type', 'rating', 'htm', 'description', 'similarity_score']]

# Contoh penggunaan
print("\nContoh Rekomendasi Berbasis Deskripsi:")
display(recommend_places_content_based_desc("Candi Borobudur", cosine_sim_df_desc, top_n=10, original_tourism_df=tourism_df))

"""Insight:
- Fungsi rekomendasi tempat wisata berdasarkan kemiripan deskripsi menggunakan Content-based Filtering.
- Fungsi mengembalikan daftar tempat wisata paling mirip dengan input berdasarkan nilai cosine similarity.
"""

def precision_at_k(recommended_items, relevant_items, k):
    """
    Precision@K: proporsi item relevan di top-K hasil rekomendasi.
    """
    if k == 0: return 0.0
    hits = sum(1 for item in recommended_items[:k] if item in relevant_items)
    return hits / k

def recall_at_k(recommended_items, relevant_items, k):
    """
    Recall@K: proporsi item relevan yang berhasil direkomendasikan.
    """
    if not relevant_items: return 0.0
    hits = sum(1 for item in recommended_items[:k] if item in relevant_items)
    return hits / len(relevant_items)

def calculate_ndcg_at_k(recommended_items, relevant_scores_series, k):
    """
    NDCG@K: mengukur kualitas ranking berdasarkan relevansi dan posisi.
    """
    dcg = 0.0
    relevant_items_set = set(relevant_scores_series.index)

    for i, item in enumerate(recommended_items[:k]):
        rel = 1 if item in relevant_items_set else 0
        dcg += rel / math.log2(i + 2)

    ideal_k = min(len(relevant_scores_series), k)
    idcg = sum(1 / math.log2(i + 2) for i in range(ideal_k))

    return dcg / idcg if idcg > 0 else 0.0

"""**Insight:**

1. Precision@K mengukur seberapa banyak item relevan yang berhasil muncul di daftar rekomendasi teratas sebanyak K item.
2. Recall@K menilai sejauh mana sistem berhasil menemukan semua item relevan yang tersedia.
3. NDCG@K (Normalized Discounted Cumulative Gain) mengevaluasi kualitas urutan rekomendasi dengan mempertimbangkan relevansi dan posisi item — semakin atas item relevan muncul, semakin baik.
"""

def evaluate_cbf_description_global(tourism_df, sim_df, k=5, relevance_threshold=0.3):
    """
    Evaluasi global Content-Based Filtering berbasis deskripsi (TF-IDF) menggunakan Precision@K, Recall@K, dan NDCG@K.

    :param tourism_df: DataFrame data wisata asli.
    :param sim_df: DataFrame similarity antar tempat wisata (berbasis deskripsi).
    :param k: jumlah top-k item yang direkomendasikan.
    :param relevance_threshold: nilai threshold similarity untuk menentukan item relevan.
    :return: tuple (avg_precision, avg_recall, avg_ndcg)
    """
    precisions, recalls, ndcgs = [], [], []

    for place_name in sim_df.index:
        if place_name not in sim_df.columns:
            continue

        similarities = sim_df.loc[place_name].drop(place_name, errors='ignore')
        relevant_scores = similarities[similarities >= relevance_threshold]

        if relevant_scores.empty:
            continue

        relevant_set = set(relevant_scores.index)

        recommendations = recommend_places_content_based_desc(
            place_name, sim_df, top_n=k, original_tourism_df=tourism_df
        )

        if not isinstance(recommendations, pd.DataFrame) or recommendations.empty:
            continue

        recommended_names = recommendations['name'].tolist()[:k]

        prec = precision_at_k(recommended_names, relevant_set, k)
        rec = recall_at_k(recommended_names, relevant_set, k)
        ndcg = calculate_ndcg_at_k(recommended_names, relevant_scores, k)

        precisions.append(prec)
        recalls.append(rec)
        ndcgs.append(ndcg)

    avg_precision = np.mean(precisions) if precisions else 0.0
    avg_recall = np.mean(recalls) if recalls else 0.0
    avg_ndcg = np.mean(ndcgs) if ndcgs else 0.0

    print(f"\nEvaluasi Global Content-Based Filtering (Deskripsi TF-IDF):")
    print(f"Avg Precision@{k}: {avg_precision:.4f}")
    print(f"Avg Recall@{k}: {avg_recall:.4f}")
    print(f"Avg NDCG@{k}: {avg_ndcg:.4f}")

    return avg_precision, avg_recall, avg_ndcg

"""**Insight:**
- Fungsi mengevaluasi performa sistem rekomendasi berbasis deskripsi dengan metrik Precision@K, Recall@K, dan NDCG@K.
- Menggunakan threshold similarity untuk menentukan item yang dianggap relevan.
- Hasil evaluasi dirata-rata dari seluruh tempat wisata yang valid untuk memberikan gambaran umum akurasi rekomendasi.
"""

# Evaluasi Content-Based Filtering berbasis deskripsi (TF-IDF) dengan NDCG yang dikoreksi
print("\nEvaluasi CBF Deskripsi (TF-IDF) dengan Perhitungan NDCG yang Diperbaiki...")

avg_precision_desc_corr, avg_recall_desc_corr, avg_ndcg_desc_corr = evaluate_cbf_description_global(
    tourism_df_pre,          # Data tempat wisata
    cosine_sim_df_desc,      # Matriks similarity antar deskripsi tempat
    k=5,                     # Top-K rekomendasi
    relevance_threshold=0.3  # Ambang relevansi similarity
)

# Visualisasi hasil evaluasi global Content-Based Filtering (TF-IDF deskripsi)
metrics = ['Precision@5', 'Recall@5', 'NDCG@5']
scores = [avg_precision_desc_corr, avg_recall_desc_corr, avg_ndcg_desc_corr]

plt.figure(figsize=(8, 5))
bars = plt.bar(metrics, scores, color=['skyblue', 'lightgreen', 'salmon'])

# Atur batas atas Y-axis agar ada ruang di atas bar
plt.ylim(0, max(max(scores) * 1.1, 1.05))
plt.title('Evaluasi Rekomendasi CBF (Deskripsi TF-IDF)')
plt.ylabel('Skor')
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Tampilkan skor di atas masing-masing bar
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width() / 2, height + 0.01, f'{height:.4f}', ha='center', fontsize=10)

plt.tight_layout()
plt.show()

"""# Modeling Collaborative Filtering

### Pre Processing Encoding
"""

# Gabungkan data rating, user, dan tempat wisata
cf_df = rating_df.merge(user_df, on='User_Id').merge(tourism_df[['place_id', 'name']], left_on='Place_Id', right_on='place_id')

# Lakukan label encoding untuk user dan tempat wisata
user_encoder = LabelEncoder()
place_encoder = LabelEncoder()
cf_df['user_enc'] = user_encoder.fit_transform(cf_df['User_Id'])
cf_df['place_enc'] = place_encoder.fit_transform(cf_df['place_id'])

# Simpan mapping asli untuk keperluan inferensi
user_id_map = dict(zip(cf_df['User_Id'], cf_df['user_enc']))
place_id_map = dict(zip(cf_df['place_id'], cf_df['place_enc']))

# Tampilkan contoh hasil encoding
cf_df[['User_Id', 'user_enc', 'place_id', 'place_enc', 'Place_Ratings']].head()

"""**Insight:**
- Data rating digabung dengan informasi user dan tempat wisata, lalu dilakukan label encoding untuk mengubah ID user dan tempat ke format numerik agar bisa digunakan dalam model.
- Mapping asli disimpan untuk kebutuhan interpretasi hasil rekomendasi nanti.

### Modelling dan Rekomendasi
"""

# Fitur dan label
X = cf_df[['user_enc', 'place_enc']].values
y = cf_df['Place_Ratings'].values

# Split ke training dan test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Definisikan kembali RecommenderNet jika belum
class RecommenderNet(Model):
    def __init__(self, num_users, num_places, embedding_size=50, **kwargs):
        super(RecommenderNet, self).__init__(**kwargs)
        self.user_embedding = layers.Embedding(num_users, embedding_size, embeddings_initializer='he_normal')
        self.user_bias = layers.Embedding(num_users, 1)
        self.place_embedding = layers.Embedding(num_places, embedding_size, embeddings_initializer='he_normal')
        self.place_bias = layers.Embedding(num_places, 1)

    def call(self, inputs):
        user_vector = self.user_embedding(inputs[:, 0])
        user_bias = self.user_bias(inputs[:, 0])
        place_vector = self.place_embedding(inputs[:, 1])
        place_bias = self.place_bias(inputs[:, 1])
        dot_product = tf.reduce_sum(user_vector * place_vector, axis=1, keepdims=True)
        return dot_product + user_bias + place_bias

# Inisialisasi dan Kompilasi Model
num_users = cf_df['user_enc'].nunique()
num_places = cf_df['place_enc'].nunique()

model = RecommenderNet(num_users, num_places)
model.compile(optimizer='adam', loss='mse', metrics=['mae'])

"""Insight:
- Dibuat model rekomendasi menggunakan neural network dengan embedding untuk user dan tempat wisata guna menangkap preferensi laten.
- Model menghitung interaksi user dan tempat dengan dot product ditambah bias khusus user dan tempat.
- Model dikompilasi menggunakan optimizer Adam dan loss MSE untuk prediksi rating numerik
"""

# Train
history = model.fit(
    x=X_train,
    y=y_train,
    validation_data=(X_test, y_test),
    epochs=20,
    batch_size=64,
    verbose=1,
)

loss, mae = model.evaluate(X_test, y_test, verbose=1)
print(f"Test Loss: {loss:.4f}, MAE: {mae:.4f}")

# Visualisasi Loss
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Training & Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss (MSE)')
plt.legend()
plt.grid(True)

# Visualisasi MAE
plt.subplot(1, 2, 2)
plt.plot(history.history['mae'], label='Train MAE')
plt.plot(history.history['val_mae'], label='Validation MAE')
plt.title('Training & Validation MAE')
plt.xlabel('Epoch')
plt.ylabel('MAE')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# Buat reverse mapping dari encoded ke id asli
reverse_place_map = {v: k for k, v in place_id_map.items()}

def recommend_top_n(user_id, n=5):
    user_idx = user_id_map.get(user_id)
    if user_idx is None:
        print("User tidak ditemukan.")
        return pd.DataFrame()

    # Ambil semua encoded tempat wisata
    all_places = np.arange(num_places)

    # Buat input (user, place) untuk prediksi
    user_input = np.array([[user_idx, place_id] for place_id in all_places])

    # Prediksi rating
    predicted_ratings = model.predict(user_input).flatten()

    # Ambil top-N rekomendasi
    top_indices = predicted_ratings.argsort()[::-1][:n]
    top_place_enc = all_places[top_indices]
    top_place_ids = [reverse_place_map[enc] for enc in top_place_enc]

    # Ambil info tempat dari tourism_df, sekarang termasuk htm dan deskripsi
    recommendations = tourism_df[
        tourism_df['place_id'].isin(top_place_ids)
    ][['place_id', 'name', 'type', 'rating', 'htm', 'description']]

    # Tambahkan skor prediksi ke dalam hasil rekomendasi
    recommendations = recommendations.copy()
    recommendations['predicted_rating'] = [
        predicted_ratings[all_places.tolist().index(place_encoder.transform([pid])[0])] for pid in recommendations['place_id']
    ]

    # Urutkan hasil akhir berdasarkan skor prediksi tertinggi
    recommendations = recommendations.sort_values(by='predicted_rating', ascending=False).reset_index(drop=True)

    return recommendations[['name', 'type', 'rating', 'htm', 'description']]

"""**Insight:**
- Fungsi merekomendasikan top-N destinasi wisata berdasarkan prediksi rating model untuk user tertentu, menggunakan kombinasi semua tempat dan ID user.
- Hasil rekomendasi disusun berdasarkan skor prediksi tertinggi dan diperkaya dengan informasi tempat dari tourism_df.
"""

recommend_top_n(user_id=1, n=10)

"""# **Kesimpulan**

Proyek berhasil membangun dua jenis sistem rekomendasi:
1. **Content-Based Filtering:** Model Content-Based Filtering telah berhasil dibangun untuk merekomendasikan tempat wisata di Jogja berdasarkan kemiripan deskripsi. Evaluasi global performa model menunjukkan hasil yang baik.
   <br>Proporsi item yang relevan mencapai 0.7483 (Precision@5). Kemampuan model dalam menemukan item relevan dari total item relevan yang tersedia mencapai 0.7839 (Recall@5), serta kualitas urutan rekomendasi (NDCG@5) sebesar 0.9991. <br><br>
2. **Collaborative Filtering:** Model Collaborative Filtering dilatih dan dievaluasi. Evaluasi model menunjukkan kinerja yang baik dengan nilai MAE sebesar 1.2710, membuktikan efektivitasnya dalam menangkap preferensi user.efektivitasnya dalam menangkap preferensi user.
  
   - Hasil rekomendasi sesuai dan relevan dengan tujuan awal proyek.
   - Sistem dapat diperluas ke konteks wisata daerah lain atau ditambahkan fitur seperti ulasan pengguna.

Berdasarkan kedua model tersebut, rekomendasi wisata Jogja dapat dihasilkan, menampilkan nama tempat, tipe, rating, HTM, dan deskripsi untuk membantu user dalam memilih destinasi.
"""